// Author: dWallet Labs, Ltd.
// SPDX-License-Identifier: BSD-3-Clause-Clear

//! This module wraps around the `bulletproofs` crate, and implements the `RangeProof` and `AggregatableRangeProof` traits.
//!
//! We extend `bulletproofs` to support aggregation of an arbitrary number of parties (not necessarily a power of two),
//!
//! We do that by padding the provers list with artificial provers that have a witness of zeros.
//! They also use zero nonces. In this way, everyone can simulate them efficiently and pad the proof.

pub mod commitment_round;
pub mod decommitment_round;
pub mod proof_aggregation_round;
pub mod proof_share_round;

use std::{
    array,
    collections::{HashMap, HashSet},
    iter,
};

use bulletproofs::{BulletproofGens, PedersenGens};
use commitment::{MultiPedersen, Pedersen};
use crypto_bigint::{rand_core::CryptoRngCore, U256, U64};
use curve25519_dalek::ristretto::RistrettoPoint;
use group::{helpers::FlatMapResults, ristretto, GroupElement as _, PartyID};
use merlin::Transcript;
pub use proof_aggregation_round::Output;
use serde::{Deserialize, Serialize};

use crate::{
    range::{
        AggregatableRangeProof, CommitmentScheme, CommitmentSchemeCommitmentSpaceGroupElement,
        CommitmentSchemeMessageSpaceGroupElement, CommitmentSchemeRandomnessSpaceGroupElement,
        ProofAggregationRoundParty,
    },
    Error, Result,
};

/// A wrapper around `bulletproofs::RangeProof` that optionally adds the `aggregation_commitments`
/// for aggregated range proofs.
///
/// Whilst bulletproofs claim to have a constant-size proof and support
/// aggregation, these claims are false: the commitments aren't aggregated but are instead
/// concatenated, so that the commitment for the aggregated proofs is O(n) in the number of parties
/// and so is the verification time.
///
/// This breaks our `range::RangeProof` and `proofs::aggregation` interfaces, but since this is due
/// to the fact bulletproofs aren't actually aggregatable, we decided to think of the aggregated
/// proof as a (non-constant) struct that holds both what bulletproofs says is the proof and the
/// commitment.
///
/// This allows `RangeProof::verify()` to get the actual aggregated commitment as the parameter
/// and compare them to the non-aggregated `aggregation_commitments`, whilst still allowing for the
/// implementation to use the individual `commitment` of each player to verify the proof.
///
/// For non-aggregated commitment, the `commitment` generated by `bulletproofs` are valid and
/// `aggregation_commitments` can remain empty.
///
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct RangeProof {
    proof: bulletproofs::RangeProof,
    aggregation_commitments: Vec<ristretto::GroupElement>,
}

pub const RANGE_CLAIM_BITS: usize = 32;

pub const COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS: usize = ristretto::SCALAR_LIMBS;

impl super::RangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS> for RangeProof {
    const NAME: &'static str = "Bulletproofs over the Ristretto group";

    const RANGE_CLAIM_BITS: usize = RANGE_CLAIM_BITS;

    type RangeClaimGroupElement = ristretto::Scalar;

    type CommitmentScheme<const NUM_RANGE_CLAIMS: usize> = MultiPedersen<
        NUM_RANGE_CLAIMS,
        COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
        ristretto::Scalar,
        ristretto::GroupElement,
    >;

    type PublicParameters<const NUM_RANGE_CLAIMS: usize> = PublicParameters<NUM_RANGE_CLAIMS>;

    fn prove<const NUM_RANGE_CLAIMS: usize>(
        _public_parameters: &Self::PublicParameters<NUM_RANGE_CLAIMS>,
        witnesses: Vec<
            commitment::MessageSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                Self::CommitmentScheme<NUM_RANGE_CLAIMS>,
            >,
        >,
        commitments_randomness: Vec<
            commitment::RandomnessSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                Self::CommitmentScheme<NUM_RANGE_CLAIMS>,
            >,
        >,
        transcript: Transcript,
        rng: &mut impl CryptoRngCore,
    ) -> Result<(
        Self,
        Vec<
            commitment::CommitmentSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                Self::CommitmentScheme<NUM_RANGE_CLAIMS>,
            >,
        >,
    )> {
        let number_of_witnesses = witnesses.len();

        // As bulletproofs proves a single witness, flatten the witnesses vector
        // from an entry over `NUM_RANGE_CLAIMS` to a vector of individual range claims.
        let witnesses: Vec<_> = witnesses
            .into_iter()
            .flat_map(<[_; NUM_RANGE_CLAIMS]>::from)
            .collect();

        // Bulletproofs think of range claims as numbers and not scalars.
        // Transitioning, whilst ensuring they are in range.
        let witnesses: Vec<_> = witnesses.into_iter().map(U256::from).collect();

        if witnesses
            .iter()
            .any(|witness| witness >= &(U256::ONE << RANGE_CLAIM_BITS))
        {
            return Err(Error::InvalidParameters)?;
        }

        let witnesses: Vec<u64> = witnesses
            .into_iter()
            .map(|witness| U64::from(&witness).into())
            .collect();

        // Similarly, flatten commitments randomnesses.
        let commitments_randomness: Vec<_> = commitments_randomness
            .into_iter()
            .flat_map(|multicommitment_randomness| {
                <[_; NUM_RANGE_CLAIMS]>::from(multicommitment_randomness)
            })
            .map(curve25519_dalek::scalar::Scalar::from)
            .collect();

        // Bulletproofs' API supports power-of-two-sized batching exclusively.
        // To handle that, we pad to the next power-of-two with a witness zero and randomness zero.
        let padded_witnesses_length = witnesses
            .len()
            .checked_next_power_of_two()
            .ok_or(Error::InvalidParameters)?;
        let mut iter = witnesses.into_iter();
        let witnesses: Vec<u64> = iter::repeat_with(|| iter.next().unwrap_or(0u64))
            .take(padded_witnesses_length)
            .collect();

        let mut iter = commitments_randomness.into_iter();
        let commitments_randomness: Vec<curve25519_dalek::scalar::Scalar> =
            iter::repeat_with(|| {
                iter.next()
                    .unwrap_or(curve25519_dalek::scalar::Scalar::zero())
            })
            .take(padded_witnesses_length)
            .collect();

        let bulletproofs_generators = BulletproofGens::new(
            <Self as super::RangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS>>::RANGE_CLAIM_BITS,
            witnesses.len(),
        );
        let commitment_generators = PedersenGens::default();

        let (proof, commitments) = bulletproofs::RangeProof::prove_multiple_with_rng(
            bulletproofs_generators,
            commitment_generators,
            transcript,
            witnesses.as_slice(),
            commitments_randomness.as_slice(),
            <Self as super::RangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS>>::RANGE_CLAIM_BITS,
            rng,
        ).map_err(|_| Error::InvalidParameters)?;

        let mut commitments_iter = commitments
            .into_iter()
            .map(|compressed_commitment| {
                compressed_commitment
                    .try_into()
                    .map_err(|_| Error::InternalError)
            })
            .collect::<Result<Vec<_>>>()?
            .into_iter();

        let commitments: Result<Vec<_>> = iter::repeat_with(|| {
            // Un-flatten individual commitments to a multi-commitment,
            // to fit the `RangeProof` API which returns a vector of commitments over
            // `NUM_RANGE_CLAIMS` elements.
            array::from_fn(|_| commitments_iter.next().ok_or(Error::InvalidParameters))
                .flat_map_results()
                .map(
                    commitment::CommitmentSpaceGroupElement::<
                        COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                        Self::CommitmentScheme<NUM_RANGE_CLAIMS>,
                    >::from,
                )
        })
        .take(number_of_witnesses)
        .collect();

        Ok((RangeProof::new(proof), commitments?))
    }

    fn verify<const NUM_RANGE_CLAIMS: usize>(
        &self,
        _public_parameters: &Self::PublicParameters<NUM_RANGE_CLAIMS>,
        commitments: Vec<
            commitment::CommitmentSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                Self::CommitmentScheme<NUM_RANGE_CLAIMS>,
            >,
        >,
        transcript: Transcript,
        rng: &mut impl CryptoRngCore,
    ) -> Result<()> {
        let commitments = if self.aggregation_commitments.is_empty() {
            let commitments: Vec<_> = commitments
                .into_iter()
                .flat_map(|multicommitment| {
                    <[ristretto::GroupElement; NUM_RANGE_CLAIMS]>::from(multicommitment)
                })
                .collect();

            let padded_commitments_length = commitments
                .len()
                .checked_next_power_of_two()
                .ok_or(Error::InvalidParameters)?;
            let identity = commitments
                .first()
                .ok_or(Error::InvalidParameters)?
                .neutral();
            let mut iter = commitments.into_iter();

            iter::repeat_with(|| iter.next().unwrap_or(identity))
                .take(padded_commitments_length)
                .collect()
        } else {
            if commitments
                != Self::aggregate_commitments(
                    commitments.len(),
                    self.aggregation_commitments.clone(),
                )?
            {
                return Err(Error::ProofVerification);
            }

            self.aggregation_commitments.clone()
        };

        let compressed_commitments: Vec<_> = commitments
            .into_iter()
            .map(RistrettoPoint::from)
            .map(|point| point.compress())
            .collect();

        let bulletproofs_generators = BulletproofGens::new(
            <Self as super::RangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS>>::RANGE_CLAIM_BITS,
            compressed_commitments.len(),
        );
        let commitment_generators = PedersenGens::default();

        let mut transcript = transcript;

        self.proof.verify_multiple_with_rng(
            &bulletproofs_generators,
            &commitment_generators,
            &mut transcript,
            compressed_commitments.as_slice(),
            <Self as super::RangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS>>::RANGE_CLAIM_BITS,
            rng,
        ).map_err(|e| match e {
            bulletproofs::ProofError::VerificationError => Error::OutOfRange,
            _ => Error::InvalidParameters
        })
    }
}

impl AggregatableRangeProof<COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS> for RangeProof {
    type AggregationCommitmentRoundParty<const NUM_RANGE_CLAIMS: usize> =
        commitment_round::Party<NUM_RANGE_CLAIMS>;

    fn new_session<const NUM_RANGE_CLAIMS: usize>(
        party_id: PartyID,
        provers: HashSet<PartyID>,
        initial_transcript: Transcript,
        _public_parameters: &Self::PublicParameters<NUM_RANGE_CLAIMS>,
        witnesses: Vec<
            CommitmentSchemeMessageSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                NUM_RANGE_CLAIMS,
                Self,
            >,
        >,
        commitments_randomness: Vec<
            CommitmentSchemeRandomnessSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                NUM_RANGE_CLAIMS,
                Self,
            >,
        >,
    ) -> Self::AggregationCommitmentRoundParty<NUM_RANGE_CLAIMS> {
        commitment_round::Party {
            party_id,
            provers,
            initial_transcript,
            witnesses,
            commitments_randomness,
        }
    }

    fn individual_commitments<const NUM_RANGE_CLAIMS: usize>(
        proof_aggregation_round_party: &ProofAggregationRoundParty<
            NUM_RANGE_CLAIMS,
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            Self,
        >,
        batch_size: usize,
    ) -> Result<
        HashMap<
            PartyID,
            Vec<
                CommitmentSchemeCommitmentSpaceGroupElement<
                    COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                    NUM_RANGE_CLAIMS,
                    Self,
                >,
            >,
        >,
    > {
        proof_aggregation_round_party
            .individual_commitments
            .clone()
            .into_iter()
            .map(|(party_id, commitments)| {
                let mut commitments_iter = commitments.into_iter();

                iter::repeat_with(|| {
                    array::from_fn(|_| commitments_iter.next().ok_or(Error::InternalError))
                        .flat_map_results()
                        .map(
                            CommitmentSchemeCommitmentSpaceGroupElement::<
                                { COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS },
                                NUM_RANGE_CLAIMS,
                                Self,
                            >::from,
                        )
                })
                .take(batch_size)
                .collect::<Result<Vec<_>>>()
                .map(|unflattened_commitments| (party_id, unflattened_commitments))
            })
            .collect()
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct PublicParameters<const NUM_RANGE_CLAIMS: usize> {
    pub commitment_scheme_public_parameters: commitment::PublicParameters<
        COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
        MultiPedersen<
            NUM_RANGE_CLAIMS,
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            ristretto::Scalar,
            ristretto::GroupElement,
        >,
    >,
    pub number_of_range_claims: usize,
}

impl<const NUM_RANGE_CLAIMS: usize> Default for PublicParameters<NUM_RANGE_CLAIMS> {
    fn default() -> Self {
        let scalar_public_parameters = ristretto::scalar::PublicParameters::default();
        let group_public_parameters = ristretto::group_element::PublicParameters::default();

        let commitment_generators = PedersenGens::default();

        let commitment_scheme_public_parameters = commitment::PublicParameters::<
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            Pedersen<
                1,
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                ristretto::Scalar,
                ristretto::GroupElement,
            >,
        >::new::<
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            ristretto::Scalar,
            ristretto::GroupElement,
        >(
            scalar_public_parameters,
            group_public_parameters,
            [commitment_generators.B.compress().try_into().unwrap()],
            commitment_generators
                .B_blinding
                .compress()
                .try_into()
                .unwrap(),
        )
        .into();

        Self {
            commitment_scheme_public_parameters,
            number_of_range_claims: NUM_RANGE_CLAIMS,
        }
    }
}

impl<const NUM_RANGE_CLAIMS: usize>
    AsRef<
        commitment::PublicParameters<
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            MultiPedersen<
                NUM_RANGE_CLAIMS,
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                ristretto::Scalar,
                ristretto::GroupElement,
            >,
        >,
    > for PublicParameters<NUM_RANGE_CLAIMS>
{
    fn as_ref(
        &self,
    ) -> &commitment::PublicParameters<
        COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
        MultiPedersen<
            NUM_RANGE_CLAIMS,
            COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
            ristretto::Scalar,
            ristretto::GroupElement,
        >,
    > {
        &self.commitment_scheme_public_parameters
    }
}

impl RangeProof {
    fn new(proof: bulletproofs::RangeProof) -> Self {
        Self {
            proof,
            aggregation_commitments: vec![],
        }
    }

    fn new_aggregated<const NUM_RANGE_CLAIMS: usize>(
        proof: bulletproofs::RangeProof,
        number_of_witnesses: usize,
        aggregation_commitments: Vec<ristretto::GroupElement>,
    ) -> Result<(
        Self,
        Vec<
            commitment::CommitmentSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                CommitmentScheme<
                    COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                    NUM_RANGE_CLAIMS,
                    Self,
                >,
            >,
        >,
    )> {
        let aggregated_commitments =
            Self::aggregate_commitments(number_of_witnesses, aggregation_commitments.clone())?;

        let range_proof = Self {
            proof,
            aggregation_commitments,
        };

        Ok((range_proof, aggregated_commitments))
    }

    fn aggregate_commitments<const NUM_RANGE_CLAIMS: usize>(
        number_of_witnesses: usize,
        aggregation_commitments: Vec<ristretto::GroupElement>,
    ) -> Result<
        Vec<
            commitment::CommitmentSpaceGroupElement<
                COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                CommitmentScheme<
                    COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS,
                    NUM_RANGE_CLAIMS,
                    Self,
                >,
            >,
        >,
    > {
        let number_of_padded_witnesses = number_of_witnesses
            .checked_mul(NUM_RANGE_CLAIMS)
            .and_then(usize::checked_next_power_of_two)
            .ok_or(Error::InvalidParameters)?;

        if aggregation_commitments.is_empty()
            || number_of_padded_witnesses == 0
            || !aggregation_commitments.len().is_power_of_two()
            || aggregation_commitments.len() <= number_of_padded_witnesses
        {
            return Err(Error::InvalidParameters);
        }

        // safe to divide as both are non-zero powers of two, and aggregation_commitments.len() bigger than number_of_padded_witnesses.
        let number_of_padded_parties = aggregation_commitments.len() / number_of_padded_witnesses;

        let bulletproofs_aggregated_commitments = (0..number_of_padded_witnesses)
            .map(|i| {
                (0..number_of_padded_parties)
                    .map(|j: usize| {
                        let res = j
                            .checked_mul(number_of_padded_witnesses)
                            .and_then(|index| index.checked_add(i))
                            .and_then(|index| aggregation_commitments.get(index).cloned());

                        res.ok_or(Error::InternalError)
                    })
                    .collect::<Result<Vec<_>>>()
            })
            .collect::<Result<Vec<_>>>()?;

        let bulletproofs_aggregated_commitments: Result<Vec<_>> =
            bulletproofs_aggregated_commitments
                .into_iter()
                .map(|v| {
                    v.into_iter()
                        .reduce(|a, b| a + b)
                        .ok_or(Error::InternalError)
                })
                .collect();

        let mut bulletproofs_aggregated_commitments_iter =
            bulletproofs_aggregated_commitments?.into_iter();

        iter::repeat_with(|| {
            array::from_fn(|_| {
                bulletproofs_aggregated_commitments_iter
                    .next()
                    .ok_or(Error::InternalError)
            })
            .flat_map_results()
            .map(
                CommitmentSchemeCommitmentSpaceGroupElement::<
                    { COMMITMENT_SCHEME_MESSAGE_SPACE_SCALAR_LIMBS },
                    NUM_RANGE_CLAIMS,
                    Self,
                >::from,
            )
        })
        .take(number_of_witnesses)
        .collect::<Result<Vec<_>>>()
    }
}

#[cfg(all(test, feature = "test_helpers"))]
mod tests {
    use std::collections::{HashMap, HashSet};

    use bulletproofs::range_proof_mpc::party;
    use group::ristretto::Scalar;
    use group::{PartyID, Samplable};
    use rand::{prelude::IteratorRandom, Rng};
    use rand_core::OsRng;
    use rstest::rstest;

    use super::*;
    use crate::aggregation::CommitmentRoundParty;
    use crate::{
        aggregation,
        aggregation::{test_helpers, ProofAggregationRoundParty},
        range::{bulletproofs::tests::test_helpers::commitment_round, RangeProof},
    };

    const NUM_RANGE_CLAIMS: usize = 4;

    fn generate_commitment_round_parties(
        threshold: usize,
        number_of_parties: usize,
        batch_size: usize,
    ) -> HashMap<PartyID, commitment_round::Party<NUM_RANGE_CLAIMS>> {
        let mut provers = HashSet::new();
        (1..=number_of_parties)
            .choose_multiple(&mut OsRng, threshold)
            .into_iter()
            .for_each(|i| {
                let party_id: u16 = i.try_into().unwrap();

                provers.insert(party_id);
            });

        let ristretto_scalar_public_parameters = ristretto::scalar::PublicParameters::default();

        provers
            .clone()
            .into_iter()
            .map(|party_id| {
                let transcript = Transcript::new("".as_bytes());
                let witnesses = (0..batch_size)
                    .map(|_| array::from_fn(|_| U64::from(OsRng.gen::<u32>()).into()).into())
                    .collect();

                let commitments_randomness = (0..batch_size)
                    .map(|_| {
                        array::from_fn(|_| {
                            ristretto::Scalar::sample(
                                &ristretto_scalar_public_parameters,
                                &mut OsRng,
                            )
                            .unwrap()
                        })
                        .into()
                    })
                    .collect();

                (
                    party_id,
                    commitment_round::Party {
                        party_id,
                        provers: provers.clone(),
                        initial_transcript: transcript,
                        witnesses,
                        commitments_randomness,
                    },
                )
            })
            .collect()
    }

    #[rstest]
    #[case(2, 2, 1)]
    #[case(2, 4, 3)]
    #[case(6, 9, 2)]
    #[case(6, 9, 3)]
    fn aggregates(
        #[case] threshold: usize,
        #[case] number_of_parties: usize,
        #[case] batch_size: usize,
    ) {
        let commitment_round_parties =
            generate_commitment_round_parties(threshold, number_of_parties, batch_size);

        let (_, _, _, _, _, (range_proof, commitments)) =
            test_helpers::aggregates(commitment_round_parties);

        let public_parameters = PublicParameters::default();
        let transcript = Transcript::new("".as_bytes());

        assert!(
            range_proof
                .verify(&public_parameters, commitments, transcript, &mut OsRng)
                .is_ok(),
            "aggregated range proof should verify"
        );
    }

    #[rstest]
    #[case(2, 2, 1)]
    #[case(2, 4, 3)]
    #[case(6, 9, 2)]
    #[case(6, 9, 3)]
    fn unresponsive_parties_aborts_session_identifiably(
        #[case] threshold: usize,
        #[case] number_of_parties: usize,
        #[case] batch_size: usize,
    ) {
        let commitment_round_parties =
            generate_commitment_round_parties(threshold, number_of_parties, batch_size);

        test_helpers::unresponsive_parties_aborts_session_identifiably(commitment_round_parties);
    }

    #[rstest]
    #[case(2, 2, 1)]
    #[case(2, 4, 3)]
    #[case(6, 9, 2)]
    #[case(6, 9, 3)]
    fn out_of_range_witness_aborts_identifiably(
        #[case] threshold: usize,
        #[case] number_of_parties: usize,
        #[case] batch_size: usize,
    ) {
        let commitment_round_parties =
            generate_commitment_round_parties(threshold, number_of_parties, batch_size);

        // first check that we can't assure honest parties witnesses are in range.
        let out_of_range_party_id = *commitment_round_parties.keys().next().unwrap();
        let out_of_range_witness: Scalar = (U64::ONE << RANGE_CLAIM_BITS).into();
        let in_range_witness: Scalar = (U64::ONE << (RANGE_CLAIM_BITS - 1)).into();
        let mut commitment_round_parties_with_out_of_range_witness =
            commitment_round_parties.clone();

        let mut out_of_range_party =
            commitment_round_parties_with_out_of_range_witness[&out_of_range_party_id].clone();

        out_of_range_party.witnesses[0] = [
            in_range_witness,
            out_of_range_witness,
            in_range_witness,
            in_range_witness,
        ]
        .into();

        commitment_round_parties_with_out_of_range_witness
            .insert(out_of_range_party_id, out_of_range_party);

        commitment_round_parties_with_out_of_range_witness
            .into_iter()
            .for_each(|(party_id, party)| {
                let res = party
                    .commit_statements_and_statement_mask(&mut OsRng)
                    .map(|res| (party_id, res));
                if party_id == out_of_range_party_id {
                    assert!(matches!(res.err().unwrap(), Error::InvalidParameters));
                } else {
                    assert!(res.is_ok());
                }
            });

        // now check that malicious parties cannot prove out of range witnesses.
        let provers: Vec<_> = commitment_round_parties.keys().copied().collect();
        let number_of_malicious_parties = if provers.len() == 2 { 1 } else { 2 };
        let mut malicious_parties = provers
            .clone()
            .into_iter()
            .choose_multiple(&mut OsRng, number_of_malicious_parties);

        malicious_parties.sort();

        let (mut commitments, mut decommitment_round_parties) =
            commitment_round(commitment_round_parties).unwrap();

        let bulletproofs_generators =
            BulletproofGens::new(64, number_of_parties * NUM_RANGE_CLAIMS * batch_size);

        let commitment_generators = PedersenGens::default();

        for party_id in malicious_parties.clone() {
            let mut malicious_party = decommitment_round_parties.get(&party_id).unwrap().clone();
            let mut malicious_commitments = commitments.get(&party_id).unwrap().clone();

            // Just out of range by 1.
            let out_of_range_witness = (U64::ONE << RANGE_CLAIM_BITS).into();
            let malicious_subparty = party::Party::new(
                bulletproofs_generators.clone(),
                commitment_generators,
                out_of_range_witness,
                curve25519_dalek::scalar::Scalar::zero(),
                64,
            )
            .unwrap();

            let position = (usize::from(party_id) - 1) * NUM_RANGE_CLAIMS * batch_size;

            let (malicious_subparty, commitment) = malicious_subparty
                .assign_position_with_rng(position, &mut OsRng)
                .unwrap();

            malicious_party.parties_awaiting_bit_challenge[0] = malicious_subparty;
            malicious_commitments[0] = commitment;

            decommitment_round_parties.insert(party_id, malicious_party);
            commitments.insert(party_id, malicious_commitments);
        }

        let (decommitments, proof_share_round_parties) =
            test_helpers::decommitment_round(commitments, decommitment_round_parties).unwrap();

        let (proof_shares, proof_aggregation_round_parties) =
            test_helpers::proof_share_round(decommitments, proof_share_round_parties).unwrap();

        assert!(proof_aggregation_round_parties
            .clone()
            .into_iter()
            .all(|(party_id, party)| {
                if malicious_parties.contains(&party_id) {
                    // No reason to check malicious party reported malicious behavior.
                    true
                } else {
                    let res =
                        party.aggregate_proof_shares(proof_shares.clone(), &mut OsRng);

                    matches!(
                        res.err().unwrap(),
                        Error::Aggregation(aggregation::Error::ProofShareVerification(parties)) if parties == malicious_parties
                    )
                }
            }));
    }
}
